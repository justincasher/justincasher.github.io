<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Borel&display=swap" rel="stylesheet">

    <style>
        .gradient-text {
            background: linear-gradient(to right, #F7AD28, #D62404); 
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .search-bar {
            position: relative;
            margin-top: 20px;
            margin-bottom: 0; /* Removed bottom margin */
        }

        .search-input {
            width: 100%; /* Full width of the container */
            padding: 10px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .autocomplete-dropdown {
            position: absolute;
            width: 100%; /* Full width of the container */
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-top: 5px;
            z-index: 10;
            max-height: 200px;
            overflow-y: auto;
        }

        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background-color: #f7f7f7;
        }

        .autocomplete-item a {
            text-decoration: none;
            color: #333;
        }

        .autocomplete-item a:hover {
            text-decoration: underline;
        }

        .autocomplete-item .highlight {
            background-color: yellow;
        }
    </style>
</head>

<div class="home-intro">
    <section class="section">
        <div class="columns is-centered">
            <div class="column is-6-widescreen is-8-desktop is-8-tablet is-12-mobile">
                <div style="font-family:'Borel', cursive; font-size:2.5em ">Welcome!</div>

                <h3>
                    I am a mathematician working on building 
                    <span class="gradient-text">mathematical superintelligence</span>
                </h3>
                
                <!-- CONTACT INFO -->
                <h4>
                    Email: <a href=mailto:justinchadwickasher@gmail.com>justinchadwickasher@gmail.com</a><br>
                    GitHub: <a href=https://www.github.com/justincasher>github.com/justincasher</a><br>
                    LinkedIn: <a href=https://www.linkedin.com/in/justin-asher>linkedin.com/in/justin-asher</a><br>
                </h4>
                
                <!-- SEARCH BAR -->
                <div class="search-bar">
                    <input 
                        type="text" 
                        id="search-input" 
                        class="search-input" 
                        placeholder="Search for an article" 
                        oninput="performSearch()" 
                        onclick="openDropdown()"
                    >
                    <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
                </div>
                
                <!-- RECENT PROJECTS -->
                <hr>

                <h5>Selected recent works</h5>
                
                <!-- Articles -->
                <h4>The need for an autoformalizer (2024)</h4>
                <p><b>Abstract.</b> &nbsp; I argue that the creation of an autoformalizer—a machine that can verify mathematics—would have monumental benefits for both academic research and industrial applications. I then discuss how one could be created.</p>
                <p class="meta-title"><a href="/the_need_for_an_autoformalizer">Read web article →</a></p>

                <h4>Modeling Catan through self-play (2024)</h4>
                <p><b>Abstract.</b> &nbsp; I taught a neural network how to play the board game Catan using reinforcement learning via self-play. When training, I utilized both temporal-difference and Monte-Carlo tree search methods, along with a residual neural network structure.</p>
                <p class="meta-title"><a href="/catan_rl">Read web article →</a></p>

                <h4>Infinity categories (2024)</h4>
                <p><b>Abstract.</b> &nbsp; In this note, we answer the question "What is an infinity category?", explaining the definition in terms of simplicial categories, ordinary category theory, and homotopy theory.</p>
                <p class="meta-title"><a href="/infinity-categories">Read web article →</a></p>

                <h4>The Ramanujan conjecture (2023)</h4>
                <p><b>Abstract.</b> &nbsp; We discuss some of the main tools used by Deligne in proving the Ramanujan conjecture. These are notes from a talk, so I do not include most proofs.</p>
                <p class="meta-title"><a href="/Ramanujan-Conjecture">Read web article →</a></p>
            </div> 
        </div>
    </section> 
</div>

<script>
    // Function to clear the search bar on page load
    window.onload = function () {
        document.getElementById('search-input').value = ''; // Clear the search bar
    };

    const articles = [
        { 
            title: 'The need for an autoformalizer', 
            link: '/the_need_for_an_autoformalizer',
            abstract: 'I argue that the creation of an autoformalizer—a machine that can verify mathematics—would have monumental benefits for both academic research and industrial applications. I then discuss how one could be created.'
        },
        { 
            title: 'Modeling Catan through self-play', 
            link: '/catan_rl',
            abstract: 'I taught a neural network how to play the board game Catan using reinforcement learning via self-play. When training, I utilized both temporal-difference and Monte-Carlo tree search methods, along with a residual neural network structure.'
        },
        { 
            title: 'Infinity categories', 
            link: '/infinity-categories',
            abstract: 'In this note, we answer the question "What is an infinity category?", explaining the definition in terms of simplicial categories, ordinary category theory, and homotopy theory.'
        },
        { 
            title: 'The Ramanujan conjecture', 
            link: '/Ramanujan-Conjecture',
            abstract: 'We discuss some of the main tools used by Deligne in proving the Ramanujan conjecture. These are notes from a talk, so I do not include most proofs.'
        }
    ];

    function performSearch() {
        const query = document.getElementById('search-input').value.toLowerCase();
        const dropdown = document.getElementById('autocomplete-dropdown');
        dropdown.innerHTML = '';

        if (query) {
            const results = articles.filter(article => 
                article.title.toLowerCase().includes(query) || 
                article.abstract.toLowerCase().includes(query)
            );

            results.forEach(article => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.innerHTML = `<a href="${article.link}">${highlightMatch(article.title, query)}</a>`;
                dropdown.appendChild(item);
            });

            if (results.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'autocomplete-item';
                noResults.textContent = 'No results found';
                dropdown.appendChild(noResults);
            }
        }
    }

    function highlightMatch(text, query) {
        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<span class="highlight">$1</span>');
    }

    function openDropdown() {
        document.getElementById('autocomplete-dropdown').style.display = 'block';
    }

    function closeDropdown() {
        document.getElementById('autocomplete-dropdown').style.display = 'none';
    }

    // Close dropdown when clicking anywhere on the page
    document.addEventListener('click', function(event) {
        const dropdown = document.getElementById('autocomplete-dropdown');
        const searchInput = document.getElementById('search-input');
        if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
            closeDropdown();
        }
    });
</script>

