<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Homepage with Search Bar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Borel&display=swap" rel="stylesheet">

    <style>
        .gradient-text {
            background: linear-gradient(to right, #F7AD28, #D62404); 
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .search-bar {
            position: relative;
            margin-top: 20px;
            margin-bottom: 0; /* Removed bottom margin */
        }

        .search-input {
            width: 100%; /* Full width of the container */
            padding: 10px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        /* Ensure placeholder is visible */
        .search-input::placeholder {
            color: #888; /* Adjust color as needed */
            opacity: 1; /* Ensure full opacity */
        }

        .autocomplete-dropdown {
            position: absolute;
            width: 100%; /* Full width of the container */
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-top: 5px;
            z-index: 10;
            max-height: 200px;
            overflow-y: auto;
            display: none; /* Initially hidden */
        }

        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background-color: #f7f7f7;
        }

        .autocomplete-item a {
            text-decoration: none;
            color: #333;
        }

        .autocomplete-item a:hover {
            text-decoration: underline;
        }

        .autocomplete-item .highlight {
            background-color: yellow;
        }
    </style>
</head>
<body>
    <div class="home-intro">
        <section class="section">
            <div class="columns is-centered">
                <div class="column is-6-widescreen is-8-desktop is-8-tablet is-12-mobile">
                    <div style="font-family:'Borel', cursive; font-size:2.5em;">Welcome!</div>

                    <h3>
                        I am a mathematician working on building 
                        <span class="gradient-text">mathematical superintelligence</span>
                    </h3>
                    
                    <!-- CONTACT INFO -->
                    <h4>
                        Email: <a href="mailto:justinchadwickasher@gmail.com">justinchadwickasher@gmail.com</a><br>
                        GitHub: <a href="https://www.github.com/justincasher">github.com/justincasher</a><br>
                        LinkedIn: <a href="https://www.linkedin.com/in/justin-asher">linkedin.com/in/justin-asher</a><br>
                    </h4>
                    
                    <!-- SEARCH BAR -->
                    <div class="search-bar">
                        <input 
                            type="text" 
                            id="search-input" 
                            class="search-input" 
                            placeholder="Search for an article" 
                            autocomplete="off" 
                            oninput="performSearch()" 
                            onclick="openDropdown()"
                        >
                        <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
                    </div>                
                    
                    <!-- RECENT PROJECTS -->
                    <hr>

                    <h5>Selected recent works</h5>
                    
                    <!-- Articles -->
                    <h4>The need for an autoformalizer (2024)</h4>
                    <p><b>Abstract.</b> &nbsp; I argue that the creation of an autoformalizer—a machine that can verify mathematics—would have monumental benefits for both academic research and industrial applications. I then discuss how one could be created.</p>
                    <p class="meta-title"><a href="/the_need_for_an_autoformalizer">Read web article →</a></p>

                    <h4>Modeling Catan through self-play (2024)</h4>
                    <p><b>Abstract.</b> &nbsp; I taught a neural network how to play the board game Catan using reinforcement learning via self-play. When training, I utilized both temporal-difference and Monte-Carlo tree search methods, along with a residual neural network structure.</p>
                    <p class="meta-title"><a href="/catan_rl">Read web article →</a></p>

                    <h4>Infinity categories (2024)</h4>
                    <p><b>Abstract.</b> &nbsp; In this note, we answer the question "What is an infinity category?", explaining the definition in terms of simplicial categories, ordinary category theory, and homotopy theory.</p>
                    <p class="meta-title"><a href="/infinity-categories">Read web article →</a></p>

                    <h4>The Ramanujan conjecture (2023)</h4>
                    <p><b>Abstract.</b> &nbsp; We discuss some of the main tools used by Deligne in proving the Ramanujan conjecture. These are notes from a talk, so I do not include most proofs.</p>
                    <p class="meta-title"><a href="/Ramanujan-Conjecture">Read web article →</a></p>
                </div> 
            </div>
        </section> 
    </div>

    <script>
        // Remove the window.onload function as it's redundant
        /*
        window.onload = function () {
            const searchInput = document.getElementById('search-input');
            searchInput.value = ''; // Clear the search bar value
            searchInput.placeholder = 'Search for an article'; // Ensure the placeholder is set
        };
        */

        const articles = [
            /* AI */
            { 
                title: 'The need for an autoformalizer', 
                link: '/the_need_for_an_autoformalizer',
                abstract: 'I argue that the creation of an autoformalizer—a machine that can verify mathematics—would have monumental benefits for both academic research and industrial applications. I then discuss how one could be created.',
                keywords: ["Justin Asher", "AI", "Math", "Artificial intelligence", "autoformalizer", "mathematical verification", "machine verification", "academic research", "industrial applications", "natural language processing", "sequence-to-sequence modeling", "large language models", "logical reasoning", "mathematical problems", "chain-of-thought prompting", "FrontierMath benchmark", "LLM mathematics benchmarks", "Lean proof assistant", "type-theoretic framework", "formal proofs", "mathematical rigor", "mathematical errors", "unit conversion error", "Mars Climate Orbiter mishap", "Knight Capital trading loss", "financial computation errors", "regulatory compliance", "civil engineering", "infrastructure failures", "Morandi Bridge collapse", "academic paper review", "automated paper review", "mathematical superintelligence", "mathematics mining machine", "mathematical research", "mathematical cognition", "mathematical innovation", "Alexander Grothendieck", "Jean Dieudonné", "Éléments de Géométrie Algébrique", "Bourbaki group", "formalized mathematics", "English-Lean dataset", "autoformalizer development", "Lean 4", "English-to-Lean translation", "Lean-to-English translation", "mathematical statements", "proof formalization", "generative adversarial networks", "reinforcement learning", "retrieval-augmented generation", "formalized tree of mathematics", "Google of math", "dynamic mathematics tree", "DeepMind", "mathematics benchmarks", "Lean workbook", "self-correcting mathematics", "mathematical superintelligence training", "specialized AI", "logical frameworks", "industrial applications of math", "academic applications of AI", "formal mathematics repository", "error detection in mathematics", "AI-assisted mathematics", "type theory", "philosophy of mathematics", "mathematical precision", "machine learning", "neural networks", "mathematical datasets"]
            },
            { 
                title: 'Modeling Catan through self-play', 
                link: '/catan_rl',
                abstract: 'I taught a neural network how to play the board game Catan using reinforcement learning via self-play. When training, I utilized both temporal-difference and Monte-Carlo tree search methods, along with a residual neural network structure.',
                keywords: ['Catan', 'reinforcement learning', 'self-play', 'neural networks', 'AI']
            },
            { 
                title: 'The brain age project', 
                link: '/brain_age_project',
                abstract: 'Our study aimed to find a new method for predicting the age of a subject from their brain biometrics. In order to measure the stretching of the brain tissue, we utilized an isoperimetric-type ratio , where is the membrane thickness and A is the surface area, for each region of the brain. We found that a multinomial logistic model trained on the ratios preserved, and improved, prediction accuracy. This showed that our dimensionality reduction technique was effective for modeling brain age.',
                keywords: ['brain age', 'biometrics', 'prediction', 'machine learning', 'dimensionality reduction']
            },
            /* Math 2024 */
            { 
                title: "Hilbert's 10th problem", 
                link: '/Hilberts-10th-problem',
                abstract: "These are notes from a talk I gave on Hilbert's 10th problem, which asks if there exists an algorithm which determines whether a polynomial with integer coefficients has a solution in the integers. We follow the proof given in B. Poonen's expository article, [6], on how Turing machines, and specifically the Halting problem, are used to show Hilbert's 10th conjecture is false. We then mention generalizations and applications to Mazur's conjecture.",
                keywords: ['Hilbert', 'polynomial', 'algorithm', 'Turing machines', 'Halting problem']
            },
            { 
                title: "Infinity categories", 
                link: '/infinity-categories',
                abstract: 'In this note, we answer the question "What is an infinity category?", explaining the definition in terms of simplicial categories, ordinary category theory, and homotopy theory.',
                keywords: ['infinity categories', 'category theory', 'simplicial categories', 'homotopy theory']
            },
            /* Math 2023 */
            { 
                title: "Cartan-Hadamard theorem for metric spaces", 
                link: '/Metric-space-CH',
                abstract: "We fill in some details in S. Alexander and R. Bishop's proof of the metric space Cartan-Hadamard theorem. Our goal is to make the proof more motivated and accessible to non-experts.",
                keywords: ['Cartan-Hadamard theorem', 'metric spaces', 'geometry', 'proof']
            },
            { 
                title: "The Casas-Alvero conjecture", 
                link: '/Casas-Alvero',
                abstract: "The Casas-Alvero Conjecture asserts that if F(X) K[X], k is of characteristic 0, and shares a root with each derivative F^(i) then for some . We show that it is true for polynomials of degree for prime following [3].",
                keywords: ['Casas-Alvero conjecture', 'polynomials', 'roots', 'characteristic']
            },
            { 
                title: "Categorical coproducts and K-theory", 
                link: '/Categorical-coproducts',
                abstract: "We define products and coproducts for arbitrary categories, then use them to define K-theories. In particular, we discuss how the integers result from this construction, and we mention the Serre-Swan Theorem.",
                keywords: ['coproducts', 'K-theory', 'categories', 'Serre-Swan theorem']
            },
            { 
                title: "Euler characteristic is the index of an operator", 
                link: '/Euler-characteristic-is-an-index',
                abstract: "Let M be a closed oriented Riemannian manifold. We show that the (analytic) index of a specific Dirac operator equals the Euler characteristic of M. This is the first step in the proof that the Atiyah-Singer index theorem implies the Chern-Gauss-Bonnet theorem.",
                keywords: ['Euler characteristic', 'index theorem', 'manifolds', 'Atiyah-Singer']
            },
            { 
                title: "The Gauss-Legendre algorithm", 
                link: '/Gauss-Legendre',
                abstract: "We prove the following approximation of which is derived from the arithmetic-geometric mean of and .",
                keywords: ['Gauss-Legendre algorithm', 'approximations', 'arithmetic-geometric mean']
            },
            { 
                title: "IU analysis qualifying solutions", 
                link: '/IU-analysis-qualifying-solutions',
                abstract: 'These are solutions to some of the Indiana University analysis qualifying problems. They are indexed by "[Year] [Semester] [Number]". I also include in each section some theorems which might be useful. I would like to thank Chia-Tz Liang and Anuvertika Pandey for pointing out errors or suggesting solutions. Please email me if you find any errors or have any solutions you would like to add. I also omitted adding a section on integration.',
                keywords: ['analysis', 'qualifying problems', 'theorems', 'solutions']
            },
            { 
                title: "Local systems as locally constant sheaves", 
                link: '/LS-as-LCS',
                abstract: 'Let be a locally simply connected space. We prove that the categories of locally constant sheaves and local systems on are equivalent.',
                keywords: ['local systems', 'constant sheaves', 'categories']
            },
            { 
                title: "Motivating schemes with the Weil conjectures", 
                link: '/Weil-conjectures-intro',
                abstract: 'We introduce the Weil Conjectures, then give an overview of how Lefschetz theory and étale cohomology can be used to prove them. I would like to thank Nathan Lowry and Vladimir Shein for useful feedback.',
                keywords: ['Weil conjectures', 'schemes', 'Lefschetz theory', 'étale cohomology']
            },
            { 
                title: "The Ramanujan conjecture", 
                link: '/Ramanujan-Conjecture',
                abstract: 'We discuss some of the main tools used by Deligne in proving the Ramanujan conjecture. These are notes from a talk, so I do not include most proofs. For a more comprehensive treatment see [1].',
                keywords: ['Ramanujan conjecture', 'Deligne', 'number theory', 'proofs']
            },
        ];

        function performSearch() {
            const query = document.getElementById('search-input').value.trim().toLowerCase();
            const dropdown = document.getElementById('autocomplete-dropdown');
            dropdown.innerHTML = '';

            if (query) {
                const queryWords = query.split(/\s+/); // Split the query into individual words
                const results = articles
                    .map(article => {
                        const text = `${article.title} ${article.abstract} ${article.keywords?.join(' ') || ''}`.toLowerCase();
                        let score = 0;

                        // Boost for exact match
                        if (text.includes(query)) {
                            score += 50; // Significant boost for exact phrase match
                        }

                        // Score based on the presence of each query word
                        queryWords.forEach(word => {
                            if (text.includes(word)) {
                                score += 10; // Exact word match gives a high score
                            } else if (fuzzyMatch(text, word)) {
                                score += 3; // Fuzzy match gives a lower score
                            }
                        });

                        return { ...article, score };
                    })
                    .filter(article => article.score > 0) // Include only articles with a non-zero score
                    .sort((a, b) => b.score - a.score); // Sort by score, highest first

                // Define a stricter threshold for relevance
                const threshold = results.length > 0 ? results[0].score * 0.7 : 0; // At least 70% of the top score
                const filteredResults = results.filter(article => article.score >= threshold).slice(0, 4); // Limit to top 4 results

                if (filteredResults.length > 0) {
                    filteredResults.forEach(article => {
                        const item = document.createElement('div');
                        item.className = 'autocomplete-item';
                        item.innerHTML = `<a href="${article.link}">${highlightMatch(article.title, query)}</a>`;
                        dropdown.appendChild(item);
                    });
                } else {
                    const noResults = document.createElement('div');
                    noResults.className = 'autocomplete-item';
                    noResults.textContent = 'No relevant results found';
                    dropdown.appendChild(noResults);
                }

                dropdown.style.display = 'block'; // Ensure dropdown is visible when there are results
            } else {
                dropdown.style.display = 'none'; // Hide dropdown when query is empty
            }
        }

        function fuzzyMatch(text, query) {
            // Basic fuzzy matching logic using Levenshtein distance
            const distance = levenshteinDistance(text, query);
            const threshold = Math.ceil(query.length * 0.3); // Allow up to 30% mismatch
            return distance <= threshold;
        }

        function levenshteinDistance(a, b) {
            const matrix = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));

            for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

            for (let i = 1; i <= a.length; i++) {
                for (let j = 1; j <= b.length; j++) {
                    const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // Deletion
                        matrix[i][j - 1] + 1, // Insertion
                        matrix[i - 1][j - 1] + cost // Substitution
                    );
                }
            }

            return matrix[a.length][b.length];
        }

        function highlightMatch(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        function openDropdown() {
            const dropdown = document.getElementById('autocomplete-dropdown');
            if (dropdown.innerHTML.trim() !== '') {
                dropdown.style.display = 'block';
            }
        }

        function closeDropdown() {
            document.getElementById('autocomplete-dropdown').style.display = 'none';
        }

        // Close dropdown when clicking anywhere on the page except the search bar
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('autocomplete-dropdown');
            const searchInput = document.getElementById('search-input');
            if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
                closeDropdown();
            }
        });
    </script>
</body>
</html>
